관계형 db는 정규화된 데이터로 다:다 관계가 될 수 없음
연결 테이블을 추가하여, 다:1 1:다로 풀어내야됨
객체는 컬렉션을 사용하여 다:다로 가능함
Member<-> Product이면
Member<->MemberProduct<->Product관계로 풀어서 정리가능
N+1문제: 스프링으로 조회하는 코드를 만들고,List타입으로 탐색을 한 값을 탐색한다면 출력이 된 것을 볼 때 다 조회한 거랑 각각의 타입이 끌어다 쓰는 것이 같이 나옴
각각의 타입이 끌어다 쓰는 것이 Lazy Loading(맨처음 전체를 조회한 것이 나오고, 그 뒤로 나오지 말아야 할 필요하지 않은 것들이 그 뒤의 데이터로 나옴) 
관련 코드를 봤는데, 이해하기 좀 어려웠다(해결법은 나중에 보기로 했다)
다른 분들 코드를 뒤져보면서 코드에 대해 이해하는데,
@query(query db에서 쓰는 문)
List<Academy> findAppConfig()
이런식으로 Academy의 리스트타입의 함수를 위처럼 query에 저장해서 짜고,
builder 패턴을 실제로, 구현하지 않고
@builder
이런식으로 애너테이션을 이용해서 쓰셔서 접근하고,
@NoArgConstructor 이런식으로 생성자를 접근 못하게 막을 수 있고,
강사님 코드를 보니까, 기존에 안되는 protected 생성자 접근이 가능하고,
공부하면 공부할 수록 스프링이라는 개념이 자바로 알고 있던 것들과는 많이 달랐던 것 같다
공부하기전에는 그냥 db랑 자바라는 언어랑 html/css/js의 프론트엔드 부분을 중간에서 작동이
가능하게 연동을 해주는 의미로만 느끼고 있었는데, 실제로 지금 배우는 스프링은
db에서 매핑해서 연동이 되도록 해주기도 하고, 기존 db에서 안되는 다:다 관계라던가 같은 기능도 지원해주고,
기존 자바였으면 싱글톤이나 플라이웨이트를 마음대로 써도 되겠지만,
규약을 정해서 싱글톤으로 작업하되, scope를 prototype으로 바꾸면(js의 prop와는 다르다..), 새로운 객체를 사용할 수 있도록 하고,
쉽게 코드를 줄일 수 있고, 자동적인 애너테이션에 내용을 수정하고 싶거나, 조금 활용해서 써야하는 상황이면 조금 더 윗단의 애너테이션을 쓸 수도 있고,
어떠한 규칙으로 만들어지는데, 그 규칙이 자바를 쓸 떄와도 다르다는 감각이 존재해서, 되게 특이하게 다가오는 구조인 것 같다.
내일은 좀 더 진도를 빼야되겠다는 생각이 들었다.

