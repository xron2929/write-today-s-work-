-32 / 8을 하려면
-32는 2의 보수로 100000이고, 8은 1000인데,
나누면 100인데, 나눌 떄 제수법으로 나눠지는 대상이 6자리니까 몫도 6자리로 뒤에 0을 붙혀서 나누면 된다
그러면 000100이 나오는데, 그러면 -4로 계산이 깔끔하게 된다
근데 나누기는 이렇게 깔끔하게 연산이 안되서 머리가 아프다
물론 곱은 이렇게 하면 깔끔하게 나오기는 한다
아마 보수 표현이 내 생각이 맞으면 2의 보수는 1이 나오는 걸 기준으로 -2라고 생각하는게 나누기 생각할 때 맞는 표현 같은데 확실하지 않아서 애매하다
2의 2보수는 0000 0010 11의 2보수는 0000 1011이라고 생각하면
  0000 0010 
 *0000 1011
 -----------
 0001 0110 = 22 이런느낌으로 계산하는게 맞는 표현 같은데,
 그러면 보수 표현할 때 0001 0110 인지 음수인지 양수인지 확실하지 않으니까 이 경우엔
 앞에 0이나 1을 붙이는 형식으로 사용하면 2-11을 할 떄, 8-2라면 한꺼번에 더할 수 있으니 뒤의 자리는 보수 맨 첫비트만 0또는 1로 덧셈 뺼셈 최적화가 가능하겠지만,
 요즘 컴퓨터는 아마 이것보다 더 빠르게 각 자리수로 동시연산해서 
 현재 자리수가 x, 뺴야될 자리수가 y 받아올림떄문에 빼야될 수가(당연하지만 이 경우는 항상 1) b(below) 결과가 r(result)라면
 (x=0 AND (b or y)) OR (x=1 AND b=1 AND y=1) 일때 r=x-b-y 이고, 해당 경우에 따라 b가 1 y가1이면 b=0 y=0으로 하거나, x=1 b=0으로 r+=2구조로 각 회로마다 최적화해서
 carry look ahead 방식으로 돌 것 같다
 3비트 컴퓨터는 아마 최적화가 되어있다면 아마 이러한 이유 떄문에 carry look ahead를 사용했을 것 같기도 하고 암튼 그렇다
 carry look ahead를 쓰면 아마 보수의 의미가 떨어질 껀데 저렇게 중간에 회로를 더 추가해줘야 해서 비용이 더 들기는 한다
 더 이상 파보는건 너무 low해서 더는 생각안할 것 같다

 
