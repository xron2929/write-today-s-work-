연관관계 매핑은 본인이 구현하려고 하는 목적에 대해 구현하기 위한 것을 제작하는 것이고,
Embedded(or class내의 값)는 하나의 객체가 가진 값들을 하나하나 객체에 저장하면 어렵기 때문에, 이걸 하나의 class타입(DTO)으로 묶어서 쉽게 사용하기 위한 방법이다
그러니까, 예를 들어 하나의 회원이 휴대폰을 주문하기 위해 주문하는 걸 구현하는게 목적이라면
회원 - 주문 - 휴대폰 주문 -휴대폰(종류)의 관계가 연관관계로 매핑된다
반대로 휴대폰번호,가입 메일,주민번호와 계정이 다 새로 가입된 계정이라면 이벤트로 문화상품권/캐시 를 주고, 회원 가입이나 이벤트로 받은 것을 취소할 수도 있다면 
회원(Embbeded 사용자정보(휴대폰 번호,가입메일,주민번호,계정))로 설정하고, 나중에 꺼내올 때 Embadded 휴대폰 번호,가입메일,...로 꺼내와서 값이 같은지 확인하는게 맞는 것 같다 
(아직 공부가 덜 되서 잘 모르겠는데, 지금까지 고민해본 느낌으로는 이렇다)
그래서 연관관계는 
회원 로그인 - 회원 - 이벤트 로직으로 생각된다.
            | 
          회원 가입
여기서 휴대폰은 연관관계가 휴대폰을 구매하기 위한 서비스를 구현하는 logic이냐, 아니면 회원이 휴대폰을 가지고 있는 logic인지에 따라 달라질 수도 있다
또 연관관계 매핑할 떄 생각할 요건은 나중에 메소드를 만들거나, 취소할 조건 같은게 있다면 새로운 개념을 class로 만들어서 거기서 취소하거나 메소드로직으로 만들어야 하는지,
아니면 단순히 VO나 DTO타입(setter,getter)인지 생각하는 게 맞는 것 같다

그리고 회원은 자신의 계정을 조회해야되는데 회원가입 예제를 통하는 것은 이상하다
따라서 내부적으로 사용자정보에 대한 class를 가지고 있다.

또한 어제 회원- 회원 가입 - 이벤트 로직 이라고 했는데, 이벤트 로직이 회원가입을 통하는 것은 좋지 않다
이벤트 떄문에 바로 회원 가입을 통한다면 이 경우도 이벤트 로직의 대상이 되기 때문이다
(물론 회원 가입 로직이 회원 계정 연결이라는 class로 두고, 여기서 로그인과 회원 가입을 다 처리하는 로직으로 두는 것이 나을 수도 있는데, 명시적으로 로그인이랑 가입이 한 눈에 들어오기 좋은 것 같다)
또 생각해봐야 할 점이 그냥 회원 logic안에서 회원 로그인과 회원 가입을 다 처리하면 되지 않냐는 점인데, 그것 보다는 회원 가입을 하면 회원 가입 Repository-> 회원 Repository 등록
회원 로그인할 때는 회원 로그인 Service -> 회원 Service -> 회원 Repository 를 통해 조회를 한다(당연히 회원 로그인 자체보다는 회원을 통한 것이 자연스럽다)

그런데 여기서 회원이 회원가입을 할 떄, 폰 번호 인증도 해야되고, 메일 인증도 해야하고, 봇이 아닌지 확인도 해야하고.., 등등 많이 까다로운 로직을 혼자 내포하면
회원 class가 담당하는게 많아진다 그래서 다른 logic으로(class또는 연관관계로) 구분했다 (이런 경우가 하나하나 특수한 메소드 로직이다)
하나의 회원은 여러계정을 회원 가입하거나 로그인 할 수 있다.(즉 로그인이나 가입이 다 쪽인 관계이면 fk)
여기서 회원 가입과 회원 로그인은 자주 값이 변경되지 않고, 회원 쪽에서 로그인하고 나중에 비밀번호나 이메일 변경같은 것이 작업될 수 있다.(다 라고 생각하지 않아도 이렇게 사고 가능)
즉 회원이 회원 가입이나 회원 로그인에 대한 pk를 가진다 회원 가입과 회원 로그인은 fk이다
다만 생각해봐야할 점이 회원 가입/회원 로그인 뿐만 아니라 비밀번호 변경 /id 조회같은 요건이 생긴다면 우리는 어떻게 처리를 하냐이다.
여기서 회원 로그인 쪽에서 한다고 생각할 수도 있는데, id 조회나 비밀번호 변경을 로그인에 두기에는 되게 애매하고, 
더구나 우리는 id 조회할 때 id 조회 - 로그인service-(repository) - 회원 이라는 이상한 절차를 가지는 느낌이다
따라서 우리는
1. 처음부터 큰 것을 내포할 수 있도록 확장성을 고려해 큰 class를 둔다(예를 들면 이 경우 회원 계정 연결이라는 class를 둔다)
다만 이 경우 혼자 너무 많은 기능을 내포하며 특정 비즈니스 로직을 가지고 있는 것들을 내부적으로 가지고 있다면
아래의 회원 로직처럼 특수한 걸 service단이란 곳에서 처리해서 repository는 최대한 간단 하게 해야한다
(다만 이런 특정 비즈니스조차도, 큰 class안에 다른 메소드로 구분할 수 있다는 점은 생각해볼 문제이다) 
어쩃든간에, 하나의 class가 너무 많은 기능을 내포하는 것은 옳지 않다고 생각한다
(아직 트랜잭션이랑 ddd에 대해 잘 모르지만 결국 계정 연결에 다 처리하게 하니까, 이게 트랜잭션 쪽에 가깝지 않나 생각한다)
2. 회원 로직에 추가한다
  id 조회 - 회원 service - 회원 repository 이런 과정이라 흐름이 자연스럽다
  마찬가지로, 비밀번호 변경 - 회원 service - 회원 repository 이런 과정이라 자연스럽다
  (이거 생각해봐야 되는데 만약 이 부분에서 코드에 문제가 생긴다면 이건 코드의 문제다 비밀번호 변경 id 변경 email 변경 이런식으로 Repository는 자주 변경이 일어나니
  각각의 변경을 두도록 해야지, vo타입으로 생성자를 통해서만 값이 변경되는건 문제가 있기 떄문에, 이런식으로 코드를 짰거나, 변경하는데, 비밀번호 인정되었는 지 확인하는 절차를 repository단에 넣었거나
  하는 것 역시, 그런 절차는 service에서 처리하는 것이 맞다)
  다만 이 경우도, 회원 class에 너무 많은 기능을 포함하고 있지만, 회원과 연결된 class가 너무 많아지면 그것 역시 부담스럽다고 생각한다
  따라서 이 경우도, 결과적으로는 시간이 나면 회원 계정 연결이라는 class를 둬야할 것이다
  다만 결과는 
            회원 가입        패스워드 변경
              |             |
  id 조회 -   회원 계정 연결 - 회원 - 이벤트 
              |             
  로그인 -------             
  이런식으로 연결 될 것이다
  (패스워드 변경은 실제 사용자 측면에서 id 조회랑 같이 하는 것이기 떄문에, 회원 계정 연결에 하는게 좋아보이기도 하는데, 회원 계정 연결에 연결된 게 너무 부담스러워 이렇게 뒀다)
  (어쨋든 간에, 이런식으로 연결을 하면, 하나의 class가 담당하는 기능을 최대한 줄여주고, 각각의 class가 담당하는 것이 직관스러워 보인다
  이 경우 회원 계정 연결 class가 내부적으로 로그인,회원가입,id 조회 이런걸 보지 않아도, 이렇게 간단한 축약표만 보고 직관적으로 와닿게 표현될 것이다)
  





