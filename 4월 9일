  며칠전에 ddd 설계방식으로 
  회원 계정 연결 - 회원 - 이벤트       
  이런식의 단점이 생긴다고 생각했는데 ddd 설계를 저번 처럼 너무 쪼개는 것이 아니라
  어차피 비밀번호 변경이랑 id 찾기를 바로 회원에 연결하는게 맞는 것 같다
  (다만 이렇게 짤 때는 comment를 남겨야 될 것 같다)
  그리고 로그인이나 회원가입이 된 계정을 취소할 떄는 로그인이나 회원가입이 아니라
  로그인 class -> 취소, 회원 가입 class -> 취소  가 아니라
  회원(계정) -> 계정 취소 가 자연스럽기 떄문에
  회원 계정 연결에 넣으면 된다
  단 방향일 때는 하나의 클래스에 담아내는 것이 맞는데 너무 어렵게 생각하지 않았는지는 한번 생각해봐야될 것 같다
  특정 비즈니스 로직이 있는 경우더라도, 그냥 하나의 클래스에 넣었을 떄의 의미가 더 자연스럽게 다가올 때가 더 많은 것 같다
  그러면 하나의 클래스가 너무 많이 담당하고 있다면?
  여기서는 그냥 DTO 타입으로 묶어서 거기서 비즈니스 로직을 포함한 코드가 더 잘 짜여진 코드일 것 같다
  (물론 이 부분도 ddd로 분해할 수 있지만, 며칠전의 자료로 보는 것처럼 결국엔 하나로 몰리는 악현상이 나타나기 때문이다)
  그래서 이것도 객체지향처럼 양방향으로 확장될 가능성이 있으며,(ddd가 양방향에는 효과적이다) 따로 구조화하는 게 맞는지,
  양방향으로 계정 탈퇴와 같은 메소드가 있다면 여기서도 갈리는 문제인 것 같다
  (회원가입은 회원이 가입하거나 로그인하고 탈퇴를 하는 것이 좋다면, 즉 양방향 세팅보다는 Member 클래스에서 회원 가입과 회원 탈퇴 메소드를 둘 다 포함하는 것이 맞다 )
  마찬가지로 주문 예제에서도
  (비회원 같은 경우는 주문 취소를 할 떄, 주문 id(또는 해당 id를 포함하고 있는 동적인 링크)랑 해당 비밀번호만 있으면 취소가 된다. 이런 경우는 회원이 주문 로직을 관리하는 것보다
  주문 로직만으로 취소를 하는 것이 맞다, 또는 나중에 비회원으로 이렇게 확장할 것이라면 Order라는 연관관계를 새로 생성하는 것이 편하다)
  설계 방식에 따라서 Member랑 Non-Member를 Client라는 틀로 묶어내고, 여기서 Client가 Order를 관리해도 되지만, 비회원에서 취소하는거랑 회원에서 취소하는 것이 비회원, 즉 가입안하는 경우
  라는 걸 생각해보면 의미가 이질적이다)
  따라서, 위와 같은 경우는 Order가 관리한다.
  (반면 비회원을 허용하지 않고, 회원 상태에서만 관리가 된다면 Order를 아무나 취소 못하게, 엄격하게 관리한다는 의미이기 때문에, (즉 편의성보다는 보안성을 고려한 경우에 이렇게 사용할 것이다)
  이런 경우에서는 Member가 Order를 관리하게 해야한다)
  즉, 클라이언트 요청사항에 따라 능동적으로 대처하는 것이 맞는 것 같다
  근데 DTO로 하면 db로 조회할 때 주문서에 같은 2개가 등록되어서 Embadded 중복이 허용되도록 코드를 짜야되고, 코드가 많아지면 직관적이지 않고, 
  Embadded 타입이 쇼핑몰 처럼 음식, 도구, 생황용품,.. 이렇게 늘면 다 중복에 대한 코드를 짜야되서 중복허용에 대한 코드가 많아져 번거롭다
  또 이미 이 상태는 Member랑 Order관계가 1대다라서 Order 중심으로 처리된 상태에서
  품목이 다 인경우가 생기니까 이걸 db로 보려면 한번 더 일대다 처리를 해야되는데, 이런 처리가 불편해지기 떄문에 이렇게 코드를 짜신 것 같다.
  
  근데 싱글테이블, join테이블을 이용하면 db에 대한 처리를 DTO로 하면 중복허용에 대한 코드에 대해서만 처리하면 되니 생각보다 고려해볼 만 할 것 같기도 하다
  (Item 이라는 추상 class에 Banana,Book 이런 값을 Order라는 주문서가 private Book book; 이런식으로 받아서 setter로 주입받으면 되기 때문이다)
  다만, 이게 각각의 class가 너무 많아지는 임계점에 도달하면 그 때는 Apple,Book,pen,mouse,keyboard,cpu,... 이런 class가 각 상황별로 많아진다면
  class도 만들어야되고, Order에서도 각각에 대해 주입해야되기 떄문에 불편할 것 같기도하다. 
  그러면 그 때는 하나의 주문에 대한 품목인 Banana,Apple 등등이(내부적으로 DTO) Order에 각각 추가해야되는데 이런 과정 자체도 불편하기 때문에,
  이런 2개의 불편함 보다는 그냥 OrderItem을 만들고 거기서, 내부적으로 DTO로 Item을 만들지, 아니면 이것도 연관관계로 만들어야 될 지는 나중에 고민해봐야 될 문제같다
  어차피 em.find()해도 안 날라가지 않나 싶었는데, em.clear()나 em.close()같이 영속성 context가 비워지면 여기서는 where문으로 조회 때려야되는데
  이 경우 프록시 객체를 이용해 영속성 콘텍스트 -> db 조회된 걸 여기서 얻어서 실제 프록시 객체랑 연결해주는 것 처럼 사용가능하다
  다만, 영속성 콘텍스트가 준영속이 되면 사라질 수 있는데 이후부터는, 프록시 객체의 값을 출력하려고 하면 에러가 뜬다
  그리고, em.find로 직접 접근하면 그때부터는 db에 접근하는 것처럼 ==비교가 가능한데, 만약 프록시를 생성하고 em.find를 했다면 
  실제 db에서 조회된 것이 프록시처럼 되고, 반대면 프록시객체가 db(영속성 콘텍스트)에서 꺼내온 것 처럼 된다
  Hibernate.initialize(refMember); 로 강제 초기화가 가능하다
  
  
  
  
    
  
  







  
 
  
