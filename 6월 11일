-32 / 8을 하려면
-32는 2의 보수로 100000이고, 8은 1000인데,
나누면 100인데, 나눌 떄 제수법으로 나눠지는 대상이 6자리니까 몫도 6자리로 뒤에 0을 붙혀서 나누면 된다
그러면 000100이 나오는데, 그러면 -4로 계산이 깔끔하게 된다
근데 나누기는 이렇게 깔끔하게 연산이 안되서 머리가 아프다
물론 곱은 이렇게 하면 깔끔하게 나오기는 한다
아마 보수 표현이 내 생각이 맞으면 2의 보수는 1이 나오는 걸 기준으로 -2라고 생각하는게 나누기 생각할 때 맞는 표현 같은데 확실하지 않아서 애매하다
2의 2보수는 0000 0010 11의 2보수는 0000 1011이라고 생각하면
  0000 0010 
 *0000 1011
 -----------
 0001 0110 = 22 이런느낌으로 계산하는게 맞는 표현 같은데,
 그러면 보수 표현할 때 0001 0110 인지 음수인지 양수인지 확실하지 않으니까 이 경우엔
 앞에 0이나 1을 붙이는 형식으로 사용하면 2-11을 할 떄, 8-2라면 한꺼번에 더할 수 있으니 뒤의 자리는 보수 맨 첫비트만 0또는 1로 최적화했을 것 같고,
 요즘 컴퓨터는 아마 각 자리수로 동시연산해서 
 현재 자리수가 x, 뺴야될 자리수가 y 받아올림떄문에 빼야될 수가(당연하지만 이 경우는 항상 1) b(below) 결과가 r(result)라면
 x=0 AND (b or y)거나, x=1 AND b=1 AND y=1 일때 r=x-b-y 이고, 해당 경우에만 +=2를 해주는 식으로, carry look ahead 방식으로 돌 것 같다
