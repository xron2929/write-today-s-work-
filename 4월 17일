현재 해시+연결리스트의 경우는 동적인 환경은 key랑 value가 같다면 해당 키를 조회할 때 O(1)을 보장한다
(정적인 경우는 해당 key에 맞춰 조회하면 되므로)
근데 이렇게 하면 발생할 수 있는 문제가 중간 연결리스트를 삭제할 떄는 O(1)을 보장하지 않는다 즉 O(N)이다
그래서, 오늘 자바에 있는 해시 연결리스트를 해보려고 했는데,
java에서 불가능하고 c언어에서만 중간 탐색을 단축+중간 연결리스트를 방문해서 시간 낭비를 방지하는 방법만 발견했다..
(단 메모리가 그만큼 낭비된다)
(방금 생각한 방법인데 나중에 자료구조 공부할 때 제대로 짜봐야겠다)
동적 연결리스트를 만들 때 전역으로 두고,
add() 함수로 head에서 nextptr를 추가하고 반환 형을 해당 노드로 리턴한 다음에
밖에서 *pos=*nextptr로 해당 노드가 가리키는 위치만 nextptr만 받은걸 보관해서, free(nextptr);로 해제하면
나중에 remove(pos); 를 이용하면 pos->prev->next=pos->next; pos->next->prev=pos->prev; 이런식으로 O(1)시간 탐색이 가능하다
이렇게 하면 동적배열을 전역으로 사용해서 메모리 낭비가 조금 있지만, 연결리스트가 엄청나게 많은 구조라면 이 쪽이 더 효과적으로 짤 수 있을 것 같은데,
c언어를 안한지 조금 되어서 오랜만에 하니까 잘 작동하는지 모르겠다. 
나중에 해봐야겠다






