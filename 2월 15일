내 깃허브를 보니 새 하얗길래 앞으로 날마다 뭐했는지라도 기록해서 유의미하게 만들어보고자 한다.
어제 멀티 스레드를 상속 받아서 사용할 때, implements로 이용하는 법을 배웠다
프로그래머스 자바 중급 강의 보고 있는데, 강사님께서는 기능을 이미 상속받고 있으면 implements를 사용하시라고 말씀하셨다
A class-> B class(a 기능 상속 + b 기능+스레드 필요) 이렇게 할 때 말이다
그래서 어제는 A class 기능 ->(상속)  B class 기능 -> (상속)C class(윗단에서 기능을 상속 받고 스레드만을 담당하는 class)->(상속) D class
이렇게 짜면 안될까 의문을 가져서 사용해보았다
그 다음 join()이라는 함수를 배워서 스레드의 출력이나 시작 범위를 start()를 쓰더라도 조정할 수 있겠다는 생각을 하였고, synchronized도 배웠는데, 
여기서도 run()이라는 함수가 있는데 이 함수가 스레드에서 상속 받은 상태고 객체가 3개인데, 이 중 2개는 스레드, 하나는 일반 class처럼 사용하면 내부적으로 어떻게 돌아갈까 이게 synchronized랑 어떤 차이가
날까 실험해보았다

s1 = new ThreadA();
s2 = new ThreadB();
s3 = new ThreadC();

s1.run();
s2.start();
s3.start();
(물론 상황은 전부 no synchronized일 떄임)
이러면 run은 일반 class의 함수처럼 작동해서
본인은 다 돌고, s2랑 s3이 랜덤하게 돌것이다 함수 작동도 마찬가지이고, 
다중 스레드지만, 동시에 하지는 않는다. 모니터가 엄청 짧은 시간동안 각 코어가 빨리 대기하고 동작할 수 있도록 해주는 것일 뿐이다
run 즉 일반 class의 함수는 지가 혼자 일 다 하고 전달한다(일 부분은 멀티 스레드, 일부분은 싱글 스레드인 상황이다)


s1.start();
s2.run();
s3.start();

위의 경우는 좀 다르다. s1.start는 본인이 앞에있어도 다음 프로세스(s2.run)가 먼저 일이 처리 될 수도 있다
s1.start() s2.start() s3.start() 이 경우에서 s1.start()보다 s2.start()가 먼저 작동되는 것처럼 나타날 때도 있는 것처럼 말이다
어쨋든 s1이나 s2가 반드시 먼저 시작한다
s2를 만나면 그 순간 자신이 다 돌고 넘겨주고, s1은 자신이 먼저 시작하거나 다음프로세스에게 넘겨주기 떄문이다.
그리고, s1,s2,s3함수안에 내부적으로 많은함수가 있다면?(s2는 일단 내부적으로도 다 돈다 그렇지만, s1과 s3은)
s1.start s2.start s3.start에서 여러번 작동하는 함수가 남아있을 떄 처럼
s1-> s2 ->s1 ->s3이나 s1-> s2->s3->s1, s2-> s3->s1->s3 이런식으로 스레드A가 처리되다가 중간에 스레드C가 돌거나 할 수 있다 다른 스레드로 돌아가면 본인 스레드는 대기상태
그러니까 함수안에 A랑 B출력하는데 다른 스레드도 있어서 A출력하고 다른 스레드로 가버릴 수도 있다는 얘기이다
여기서 s1과 s3도 그렇게 중간에 가버리면서 저런 과정이 가능하다.

s1.start();
s2.start();
s3.run();
위의 경우가 제일 쉽다
s1이 먼저 시작할 수도있고 s2가 먼저 시작할 수도 있고 s3이 먼저 시작할 수 있는데, s3은 반드시 실행하는 순간 다 돌고 끝난다.


---------------------------------------------------------
그리고, 이런 과정에서 만약 싱글 프로세스에서 멀티 코어면 java는 어떻게 처리하는 지 궁금했는데
stack overflow에서는 JVM 환경도 싱글 프로세스이고, 다중 스레드가 사용되는 순간 스레드도 늘어나게 되는 과정이라고 한다
그러면 반대로 싱글 코어 다중 스레드는 어떻게 될까 찾아봤는데
코어 하나가 왔다 갔다 처리한다고 한다. 그리고 스레드는 호출되면 그만큼 오버헤드(추가비용이라 생각하면 쉽다)가 더 든다고 한다
즉 싱글 코어인 경우 다중 스레드가 싱글 스레드보다 오히려 비효율적인 경우가 존재하고, 코어가 여러개여도 스레드가 너무 많아지면 비효율적이라는 얘기이다.
그렇다면 싱글 코어는 무조건 싱글 스레드가 좋은가?는 네트워크/io 쪽의 콘텍스트 스위칭 쪽에서는 아니라고 한다.
그리고, 다중 코어가 스레드 작업 환경을 적절히 분배하려면 적절히 일처리 하는 지를 보고 싶었는데 맥북은 htop을 이용하고, 윈도우는 작업 관리자를 이용해 각 코어를 보면 좋을 것 같다고 느꼇다.
그리고, 다중 스레드 처리 할 때는 자신의 코어의 1.5배가 적절하다고 한다
그것말고 더 공부한 내용도 많지만 그래선 열거니 더 이상 하지않겠다.
(synchronized,exception필수, 등등)

오늘은 스레드 중 notify랑 wait을 4시간동안 많이 해맸는데 그것 떄문에 참고한 예시랑 내용이 너무 많아서 간단히 설명하자면
      wait은 synchronized가 있어야하고, 이 경우
      start가 아니라 wait이 작동된 시점부터 시작
			wait이랑 notify는 번갈아서 작동시키기 위한 용도
			작동하고 있는 곳에는 class.wait() 작동 하고 싶게 할 곳은 class.notify() 
			이렇게 하고, 인스턴스로 호출해서 활용하면 될듯
      그리고 자기 class면 자기 자신을 객체로 선언해도 되지만 이 떄는 this가 낫다
오늘은 어제보다 분량이 많아서 할말은 많지만 생략하고 주석에 있는 내용만 수정해서 제출했다

     
     


