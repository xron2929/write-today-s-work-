중학교 때 c언어 수업을 들으면서, 디지털 논리회로 일부수업을 들었는데,
그 떄는 잘 몰랐는데 오늘 학은제로 디지털 논리회로 수업 들으니까, 거기서 잘 연결 안되는 부분에 대해 정리가 된다는 것을 느꼈다
1비트는 0과 1 두개만 표현가능하다
따라서 n은 2^n-1만큼 크기를 나타낸다
int가 표현 가능한 범위는  0~2^31-1(표현가능한 개수는 2^32개) 이다. 그리고 4바이트-> 32비트 이다.(즉 1바이트당 4비트) (물론 64바이트 컴파일러를 쓴다면 int는 8바이트이다)
흐름이 자연스럽게 연결된다
그리고 Int는 범위로 -(2^31)~(2^31-1)이다
(여기서 첫글자는 범위(0과1을 나타내기 때문에 1비트는 범위로 생각하지 않는다)
아날로그와 디지털 편에서 이해가 안되었는데, 아주 쉬운 퀴즈였는데, 이산단계라는 이름이 직관적으로 와닿지가 않아서 찾아보고 다시 공부하니 흐름이 이해 되었다
(이러다가 학은제 학점 3.5점은 나올지 의문이 들긴한다..)
따라서 여기에 한번 더 확장해서 생각해보면
char은 1바이트니까 하나의 문자가 표현할 수 있는 개수가 2^8개 된다는 말이다
따라서 unsigned int는 2^32-1로 생각해볼 수 있다
(여기서 첫번째 비트는 범위가 아니라 이번엔 숫자로 사용되기 떄문)
시험 때는 이산단계로 처리하는 것이라 해서 잘 몰랐는데 틀리고 나서 지금 찾아보고 공부해보니
이산 단계에서 처리하는 흐름은 아래와 같다
각 시간마다 받을 수 있는 것도 있지만,
(아두이노 센서 같은 것은 파형보다는 초당으로 받게 되어있어서 거기에 맞게 짜야됨(어차피 이 경우도 다시 생각해보면 센서도 내부적으로는 이산단계과정이고 
거기서 코딩하는 사람은편하게 윗단에서 코딩하는 것일 뿐이긴 함), 그렇지만 데이터가 자동으로 이산 단계 과정만 추출될 수도 있을 것임. 고의로 1초마다 한 걸음 2초에 한걸음 이렇게 가서
내가 갔던 거리에 대해 디지털 신호로 추출한다면 이 경우는 자동으로 이산시간신호까지 처리된 결과 값임))
전류같이 연속적인 흐름으로 들어오는 것은 처음 들어올떄 연속 신호로 바꿔서 처리해줌
여기서 시간을 기준으로 각 진폭에 대한 값을 추출함
그러면, 이렇게 시간마다 추출한 값들을 이산 (시간) 신호라고 함(이산 단계는 디지털 신호까지 처리하니 이산 시간 신호가 자연스러운듯)
여기서 디지털 신호는 여기에 양자화랑 부호화까지 같이 처리함
양자화는 여기서 2.3 4.7이렇게 실수값으로 들어온 값들을 정수로 처리해줌 0.8 이런 값은 0으로
부호화는 이런 데이터 값들을 압축해서 처리함
결과적으로 이렇게 디지털 신호를 처리하는 과정을 이산단계라고 함

앞 영상에서 Isolation 격리수준에 관한 내용에 대해 글이랑 좋은 영상있길래 그걸 찾아보았다
참고로 어제 내용 중에 db랑 관련 되는지에 대한 유무에 대해서도 적어놓아야 될 것 같아서 그냥 오늘 자료에 올려놓았다
어차피, 생각해보면 @Column으로 연결해도 member.setTeam()으로 테이블을 연결하던가, 하다못해
member.setTeamName()으로 TeamName을 직접 연결해야 된다
즉 자동으로 연결처리를 해주지않는다. @Column은 단순히 db테이블 안의 값을 등록시켜주는 것에 가깝다
그러면, 여기서 member.setTeamName()으로 team.getName()을 연결해주고,
entitycontext에 등록하고 team.setName()으로 team 바꿔주면 어차피 db는 그냥 쿼리문 날라가서,
team만 바꿔줄뿐 member 테이블의 team에는 아무런 영향을 끼치지 않는다
며칠전에 관련 글 중에, id로 넘기지 말고, 테이블은 그대로 값 넘기라는 피드백을 받으셨다고 글 올리신게 있던데 이게 id만 넘기지말고, 그냥 넘기라는 말이
유지보수도 편하고, 만약 의도적으로 자동으로 Team테이블의 기존 값이 달라진걸 출력하고 싶으면 저번에 했던 것 처럼 그냥 Member table에서 Team table만 매핑해서 그거 가져오는게
훨씬 유용하게 작동할 수 있기 때문이다(굳이 id,name 이런식으로 값 가져오면, 나중에 확장할 떄 이렇게 변경사항에 대한 변경이 취약해서, 그냥 테이블 매핑하는게 편하다)

전에 강사님꼐서는 isolation level이 read commit이어도 repeated read 보장하신다고 말씀하셨는데
오늘 그거 보고 오니까, 그게 어제 내가 올린 것과 관련이 있나 싶었는데
그거는 복수의 트랜잭션에 관한 얘기고, 내가 오늘 올린건 하나의 트랜잭션에 관해 올린 것이다.
트랜잭션 격리수준은 4개로 분리된다
READ UNCOMMITTED
READ COMMITTED
REPEATABLE READ
SERIALIZABLE
그리고,  
Dirty Read
Non-Repeatable Read
Phantom Read

트랜잭션 격리수준은 위로 올라갈수록 동시성 처리나 성능면에서 우수한 것 같다
다만 아래에 대해 취약해서, 독립적으로 테이블을 사용하기 어렵고, 이는 곧 유지보수 면에서 떨어진다

READ UNCOMMITTED은 Dirty Read, Non-Repeatable Read, Phantom Read의 문제점을 다 가지고 있다.
Dirty Read는 수정하고, 커밋도 날리지 않았는데 다른 트랜직션에서 조회하면 수정한 걸로 데이터를 가져온다. 서버가 중간에 종료되면 바뀐 값을 가져오기 떄문에 큰 위험성을 가지고 있는 것 같다
Non-Repeatable Read은 한 커밋에서 값 조회하고, 그 중간에 다른 커밋에서 값 바꾸고 커밋하고, 다시 한번 더 조회하면 그 기존 커밋값과 새로 커밋한 값이 바뀐다
(개인적으로 위의 경우 불리하게 적용할 수 있는게 트랙직션을 비동기로 처리할 경우 코드가 복잡한 로직이 되면 비동기에 불안정할 것 같은데 확실하지 않다.. 그랬으면 자료가 있어야 되는데
저부분에 대한 관련 글이 잘 보이질 않는다 synchronized로 고정시키면 되니까, 또는 비동기로 처리 안하면 되니까, 또는 REPATABLE READ를 주로 사용하니까 안 뜬건지는 모르겠다)
REPEATABLE READ의 경우 바로 아래에서도 적었지만, Phantom Read의 문제점을 가지고 있고, Non-Repeatable Read의 문제점을 가지고 있지 않은데,


READ COMMITTED는 Non-Repeatable Read, Phantom Read의 문제점을 가지고 있고,







