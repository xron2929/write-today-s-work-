며칠전에 map 이랑 list 잘못 말한 것 같은데
string이 key값으로 잡으니 O(logN)이 맞다 list는 O(N)
list는 예를 들어 2-> 3-> 7 이라는 각각의 값들이 list구조라면 여기서 중간에 있는 거 삭제하면 2가 3가리키는거 복사해서 7가리키고 3의 node만 제거하면 되기 떄문에 O(N)이다
값 바꾸는 것도 탐색하면서 O(N)일어나니까 이 부분에 대해 착각했던 것 같고,
코드 설계에 대한 부분은 해당 객체를 dto로 소유하고 있을 떄 복수를 가지고 있으면, 그 값을 중복 등록이 가능하도록 설정해야되기 떄문에 이런 경우에 DTO만 되도록 하시는 것 같다
또 dto 가지고 있을 때 비즈니스 로직에 대한 부분 잡을 때 등록하시라는 내용도 최대한 많이 구분해서, 간단하게 사용할 수 있어서 사용하는 것 같다
그래서 실습과정에서 처리할 때 @ElementCollection이나 @JoinTable도 하나의 클래스안에 집어놓으면
조금이라도 복잡해질 염려가 있어서 안하신 것 같기도 하다
이에 따라 설계하는게 맞는 방법인 것 같고, DTO에 연관관계처럼 설정해버리면 그 뒤에 연관관계가 하나 더 생겨버리면, DTO안에 DTO를 넣던가, 이상한 처리가 되버리는 것 같다
이렇게 되면 한 클래스에 DTO안의 DTO로 되는 게 혼자 많은 기능을 담당하는 것처럼 db상에는 테이블 전략으로 분리할 수 있을 지 몰라도 클래스로 보면 좋아 보이지는 않는 것 같다
그리고, 연관관계 뒤에 연관관계가 늘어나도 쉽게 늘려서 처리시킬 수 있다. 
개인적으로는 아이템 품목:아이템 처리가 이해가 안되었는데, 이렇게 생각해보니
어떤 대상이 복수가 된다면, 그건 연관관계로 늘려볼 생각을 하는게 중요한 것 같다
실습과정에서 joinTable대신 class만드는 것은 pk에서 보는 것보다 좀 더 직관적이기 때문에,
하시는 것 같다
그리고, Collection을 넣었을 떄 하나의 인터페이스에서 자식 class로 접근하거나 다형성으로 접근하면
em.persist가 에러 나고, db조회도 쉽지 않은 것 같다는 걸 확인했다
그리고, Member class에 하나의 임베디드 타입을 여러개 중복 시키는 것은 생각해보니 null 값이 들어올 수 있는 것을 db에 보여주기 떄문에 좋은 건 아닌 것 같기도 하다
따라서 위와 같이 사용하신 것 같다






