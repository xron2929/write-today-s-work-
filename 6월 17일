algorithm은 그냥 단순히 (m^e) %d를 하면 0~d-1이 나오고,
(((m^e)%d)^p%d)= m^(ed) % p 랑 동일한 것으로 단축시키고,
m^(p-1) % p = 1 인데, 식을 치환하면
m^(p-1)-1=pk (단 k는 임의의 정수) 인데, 그렇다면, 이걸 반복하는 횟수만큼 n을 잡아서 하겠다는 말인데,
결국에 !구조니까 반복하기전까지 순환하는게 4회면(예를 들어 3->9->7->1->3), (a^n)^4=a^4n이므로, 이 경우 나머지는 항상 1인 p의 곱으로 이루어진 수가 만들어지는데, 
이 수에서 1 제외한 값으로 pk의 배수를 가질 수 있는데
3 9 7 1 이렇게 앞에 나갈 떄마다 %p 소수로 잡으면 결국 n(각 자리)이렇게 묶여있는 구조라 ^n %d를 했을 때 최소의 배수가 되고
이렇게 했을 때는 mk%p=1인 최소 mk가 구해지는데, 이 값으로 p가 소수가 아니라면, 공약수 걸어서 최소의 반복횟수를 알 수도 있고,(p-1)(합성수라면 2^2*3이라면 (2^2-2^1)(3-1)=4번인 거 이렇게 알 수
있는 방법인데 좋은 방법은 아닌 것 같다
내가 생각한 방법은 아직은 찾아도 안 나오는데, 결국에 정수론으로 식은 a^x=?(mod p)라면, a^((p-1)/2)일 때 %p를 하면 1또는 p-1이 나오는 구조인데, 관련 내용은 제곱수 2차잉여 쪽이다
저기서 만약 a^((p-1)/2) %p=1이면 결국 반복횟수는 (p-1)/2이다. 즉 p-1이 10000번 반복하면 5000번은 줄일 수 있다
이유는 1이 나오면 그 다음 수에 a를 곱하고 p를 나머지 할 때(a<p) 이므로, 곱하면 a라 a^1이랑 똑같아지는 구조가 나온다
물론 p-1이 나오면 반복횟수는 p-1이 나오는데, (예를 들어 2^n % 11의 경우, 2,4,6,8,10,1,3,5,7,9) 이렇게 반복하는 구조이고, 2^3(p-1=10, 여기서 2나누면 5. 2^5=10이므로. p-1확인
이 경우에는 보면 알겠지만 10*2%11이라 그 다음 수는 9로 11-2인 구조이다. 마찬가지로 11-4=7 11-6=5 결국 
결국 a^((p-1)/2)이 1인 경우에는 p-1로 묶는 게 아니라 (p-1)/2로 묶어도 되고,
a^((p-1)/2)이 p-1인 경우에는 테이블 짤 때, a^((p-1)/2)에 대해서만 체크를 한번 하고, 그 다음 테이블 부터는 mod값 - 기존 테이블 값으로 채워넣고 p-1로 묶어도 되는 구조이다.
https://www.youtube.com/watch?v=deifygl7D5w&list=PLdEdazAwz5Q884ImnFH_5yEne0qzGHNhS&index=20
저렇게 하면 더 빠르게 돌 것 같은데 관련 로직이 안보이는데 잘 모르겠다









