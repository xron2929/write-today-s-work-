저번에 FAST IO부분에서 잘 모른다고 하던 부분이 있었는데
이제 cs 공부하니까 왜 그런지 알겠다
며칠전에 char 배열도 각각 승계작업이 일어난다고 했는데, 예전 기준인지 해석이 잘못된 것 같다
gcc기준에서는 
#include<iostream>
using namespace std;
int main() {
	char arr[2];
	printf("%d",sizeof(arr));
}
이렇게 쳐보면 대략 2비트정도로 나온다(즉 각각 4비트 단위로 인식하지 않는다)는 것을 일단 전제로 시작한다
그 다음 생각할 것이 
fread로 우리는 static으로 이미 값을 받고 해당 값을 char 배열에 넣고 시작한다
그 다음 null이라는 중간 공백으로 구분을 한다
이제 사전에 알아야 할 과정이 있는데
현재 ideone 이나 백준에서는 32비트 컴파일러를 기준으로 돈다
즉 int 하나당 4바이트라고 생각하면 된다(64비트 컴파일러는 int 하나당 8바이트)
https://www.acmicpc.net/problem/19644
이제 여기서 나는 io값은 최대 얼마인가?
처음에는 7글자이다(3*10^6은 6글자로 표현가능 + 공백 한글자)
그 다음에는 7+(3*10^6)*4이다 (기관총 범위 3*(10^6)만큼 입력하고(총 6글자+공백 한글자), 해당 입력범위에서 각각의 거리에 대한 데미지가 최대 100까지 설정하므로 (각각 3글자+공백한글자)
그 다음에는 7글자 (3*10^6) 만큼 입력된다
그러면 왜 100만에 가까운 수부터 1mb까지가 효과적이었는가?
간단하다 입력이 최악인 경우 10^6이 아니라 10^6에 가까운 값만큼 L에 입력되었기 때문이다
이제 생기는 의문은 왜 1MB보다 큰 값에서는 오히려 시간이 오래걸리냐인데, 여기서 백준에서는 반도체 관련 기술자분들이라고 해서 이게 뭔 말이지 싶었는데
https://ljhblog.tistory.com/59
메모리 연산은 리얼모드에서 최대 1MB로 8086프로세서와 교환 가능하다
여기서 8086 프로세서가 무엇이냐하면
간단히 말하면 어셈 배울 때 Thumb Instruction이라고 해서 우리가 잘아는 명령어인 EQ(동일), GE(크거나 같다),LE(작거나 같다) 등 이거 관련 명령어를 가지고 있는 친구가
8086프로세서 라는 친구인데 이게 32비트 컴퓨터랑 호환되어있다 인텔 64비트 컴퓨터도 위의 링크처럼 8086프로세서랑 동작하는 것 같다
따라서 1MB연산이 가장 최적화되어있는 상태라고 말 할 수 있다.




