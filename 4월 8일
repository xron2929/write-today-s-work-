한 값에 대한 양방향 매핑시에는 
예를 들어 team_id가 fk인 Member와 team_id가 pk인 Team이 있다면
team을 설정하고, member에서 team 테이블을 등록하면, 그 값은 내부적으로 EntityContext에서 관리하고 그 중 Member_id Team_id Member_name에 대해서만 db가 관리하도록 보낸다
여기가 다:1 연관관계의 단방향인 상태이다.
이 경우에 대해서는 하나 하나의 회원에 대해서 어떠한 팀에 속했는지에 대해서 알 수 있다
반면, 자신이 속한 팀에 누가 있는지를 얻으려고 하면
반대편인 팀에도 "자신이 속한 팀의 회원"을 얻으려고 하면 직접 추가해주어야 한다.
아직은 잘 모르겠지만, em.createQuery()로 직접 모든 회원을 db에서 조회해서, 그 중 같은 팀 id를 가지고 있는 회원들만 한꺼번에 하는것도 방법일 것이다
(이 경우, 위 처럼 자신이 속한 팀의 회원을 직접 등록안해줘도 되기 때문에 유지보수면에서 관리하기 편하지만, 생각해보면 db에 있는 모든 회원을 뒤져야되기 떄문에,
11번가,g마켓,쿠팡... 같은 대형 쇼핑몰의 경우에는 예를 들어 해당 물품들을 올린 곳이랑 거기서 그걸 판매하는 회사가 있다면 이 회사는 식품뿐만 아니라 다른 것도 관리할 가능성이 있다면
다른 제품류도 다 열어놓아야 하는데, 이걸 db에서 조회한다면 모든 제품에 대해서 다 db로 조회해야  하니 비효율적일 것이다.
동시에, 이렇게 자동으로 처리가 되면, 까먹고 해당 쇼핑몰에 판매하는 책을 추가하는 코드를 빼먹었다면 다른건 다 조회가 되는데, 해당 물품을 올리는 곳들이나 책을 올리는 곳들에 대해서만 책이 등록이
안 되는 에러가 발생하고, 이것 때문에 db처리 부분이 에러가 났는지, 연결을 할 때 잘못을 연결한건지, 등등 여러 코드를 뒤져야 하는 불상사를 막을 수 있을 것이다)

매핑하는 과정은 유지보수를 편하게 한다
예를 들어 member에서 team을 접근하는 일대다의 경우 member에서는 joinColumn으로 설정하고, team에서는 getmapped="member" 로 
해당 member에 쉽게 접근을 한다
과거에 공부했던 내용을 다시 정리하면
이렇게 설계하는 과정은 사실 member class 타입안에 이름을 넣고, Team에서 memberList들에 member를 생성해서 여기에서 접근하고 처리하게 해도 된다(물론 여기다가 분리할 로직이 있으면
내부에서 따로 분리하도록)
하지만, class를 구분하는 과정은 확장될 가능성이 있거나 담당해지는게 많아지면, 유지보수할 때 필요한 대상만 보고 싶은데, 해당 class를 봐야되는 문제점이 발생한다
(ddd는 각 class가 각 담당하는 기능에 대해 명시적이기 때문에 내부 코드를 보지않아도 직관적으로 와닿는 점이 존재한다)
그러면, 여기서 일부 함수를 분리하고, class로 둬도, 어차피 참조하다가 기능이 많은 클래스를 참조하게 된다고 얘기를 한다면 이건 설계의 결함문제이다.
따라서 ddd방식은 여러개의 class가 이런 과정을 비즈니스로직에 맞춰 유연하게 분리하는 사고인 것 같다
(확실히는 모르겠다. 여기서 명시적으로 더욱 분리할 수 있도록 Service,Repository,Domaoin,Controller단을 분리하는 과정도 내포한다)
하지만 ddd는 설계를 아무리 잘했다고 했어도, 어떠한 예외적인 상황이 발생하면 트랜잭션이랑 별차이없는 효과가 발생해 전체적인 구조를 바꿔야될수도 있는데(이래서 도메인 주도 개발 설계인것 같다)
트랜잭션 스크립트는 어차피 큰 클래스 들이 각 단에서 잘 처리해주기 때문에, 유지보수를 할 때 큰 클래스가 무슨 기능을 담당하는지 추상적이라 잘 와닿지 않을 수도 있지만,
인터페이스 분리원칙처럼 확장성을 고려해 기능과 구현을 잘 구분하는 로직같은 것만 각 상황에 맞게 처리하고, 해당 기능에 대해 큰 클래스안의 메소드에 넣는 걸 그대로 남겨줘도,
어차피 해당 클래스의 메소드안에 있는 값만 주의해서 보면 될 것 같기도 하다
(사실 이게 트랜잭션 스크립트랑 ddd인지는 아직도 잘 모르겠다)
점점 사고를 확장하면서 강의를 듣는 편인데 진도가 좀 안나가는 것 같긴하다




