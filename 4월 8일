한 값에 대한 양방향 매핑시에는 
예를 들어 team_id가 fk인 Member와 team_id가 pk인 Team이 있다면
team을 설정하고, member에서 team 테이블을 등록하면, 그 값은 내부적으로 EntityContext에서 관리하고 그 중 Member_id Team_id Member_name에 대해서만 db가 관리하도록 보낸다
여기가 다:1 연관관계의 단방향인 상태이다.
이 경우에 대해서는 하나 하나의 회원에 대해서 어떠한 팀에 속했는지에 대해서 알 수 있다
반면, 자신이 속한 팀에 누가 있는지를 얻으려고 하면
반대편인 팀에도 "자신이 속한 팀의 회원"을 얻으려고 하면 직접 추가해주어야 한다.
아직은 잘 모르겠지만, em.createQuery()로 직접 모든 회원을 db에서 조회해서, 그 중 같은 팀 id를 가지고 있는 회원들만 한꺼번에 하는것도 방법일 것이다
(이 경우, 위 처럼 자신이 속한 팀의 회원을 직접 등록안해줘도 되기 때문에 유지보수면에서 관리하기 편하지만, 생각해보면 db에 있는 모든 회원을 뒤져야되기 떄문에,
11번가,g마켓,쿠팡... 같은 대형 쇼핑몰의 경우에는 예를 들어 해당 물품들을 올린 곳이랑 거기서 그걸 판매하는 회사가 있다면 이 회사는 식품뿐만 아니라 다른 것도 관리할 가능성이 있다면
다른 제품류도 다 열어놓아야 하는데, 이걸 db에서 조회한다면 모든 제품에 대해서 다 db로 조회해야  하니 비효율적일 것이다.
동시에, 이렇게 자동으로 처리가 되면, 까먹고 해당 쇼핑몰에 판매하는 책을 추가하는 코드를 빼먹었다면 다른건 다 조회가 되는데, 해당 물품을 올리는 곳들이나 책을 올리는 곳들에 대해서만 책이 등록이
안 되는 에러가 발생하고, 이것 때문에 db처리 부분이 에러가 났는지, 연결을 할 때 잘못을 연결한건지, 등등 여러 코드를 뒤져야 하는 불상사를 막을 수 있을 것이다)

매핑하는 과정은 유지보수를 편하게 한다
예를 들어 member에서 team을 접근하는 일대다의 경우 member에서는 joinColumn으로 설정하고, team에서는 getmapped="member" 로 
해당 member에 쉽게 접근을 한다
과거에 공부했던 내용을 다시 정리하면
이렇게 설계하는 과정은 사실 member class 타입안에 이름을 넣고, Team에서 memberList들에 member를 생성해서 여기에서 접근하고 처리하게 해도 된다(물론 여기다가 분리할 로직이 있으면
내부에서 따로 분리하도록)
하지만, class를 구분하는 과정은 확장될 가능성이 있거나 담당해지는게 많아지면, 유지보수할 때 필요한 대상만 보고 싶은데, 해당 class를 봐야되는 문제점이 발생한다
(ddd는 각 class가 각 담당하는 기능에 대해 명시적이기 때문에 내부 코드를 보지않아도 직관적으로 와닿는 점이 존재한다)
그러면, 여기서 일부 함수를 분리하고, class로 둬도, 어차피 참조하다가 기능이 많은 클래스를 참조하게 된다고 얘기를 한다면 이건 설계의 결함문제이다.
따라서 ddd방식은 여러개의 class가 이런 과정을 비즈니스로직에 맞춰 유연하게 분리하는 사고인 것 같다
(확실히는 모르겠다. 여기서 명시적으로 더욱 분리할 수 있도록 Service,Repository,Domaoin,Controller단을 분리하는 과정도 내포한다)
하지만 ddd는 설계를 아무리 잘했다고 했어도, 어떠한 예외적인 상황이 발생하면 트랜잭션이랑 별차이없는 효과가 발생해 전체적인 구조를 바꿔야될수도 있는데(이래서 도메인 주도 개발 설계인것 같다)
트랜잭션 스크립트는 어차피 큰 클래스 들이 각 단에서 잘 처리해주기 때문에, 유지보수를 할 때 큰 클래스가 무슨 기능을 담당하는지 추상적이라 잘 와닿지 않을 수도 있지만,
인터페이스 분리원칙처럼 확장성을 고려해 기능과 구현을 잘 구분하는 로직같은 것만 각 상황에 맞게 처리하고, 해당 기능에 대해 큰 클래스안의 메소드에 넣는 걸 그대로 남겨줘도,
어차피 해당 클래스의 메소드안에 있는 값만 주의해서 보면 될 것 같기도 하다
(사실 이게 트랜잭션 스크립트랑 ddd인지는 아직도 잘 모르겠다)
점점 사고를 확장하면서 강의를 듣는 편인데 진도가 좀 안나가는 것 같긴하다
그래서 강사님의 경우에는 이것에 대한 해결법으로 처음에 member에서 team을 만들 때, 
자동으로 Member에서 접근하는 team의 member가 자동으로 값이 늘어나도록 설정하셨다. 
이렇게 사용하면 실수가 안날 것 같은데, 다만 이 경우엔 setter를 람북으로 설정 하지말고,위에 대한 함수도 setter로 만들지 말고, 다른 함수에 setter로 접근해야할 일이 있다면 그 코드에만
setter로 접근하는게 맞는 것 같다
즉 다:1 연관관계나 1:1이지만, 1:다가 될수 있는 연관관계는 lombook보단 createTeam()같이 짜는게 맞는 것 같다
(createTeam은 내부적으로 Memberclass가 가지고 있는 team 객체가 team 객체를 참조하며 Team class에 있는 member에 관한 list 타입을 추가하는 형식이다)
(예를 들어 한명의 멤버가 하나의 팀을 결정하지만 좀 시간이 지난 뒤에, 그 멤버가 여러명이 될 수 있다면(사실 현 상황은 1:1에 적합하지만 처음부터 장기적으로 보고 다:1로 수정해야되는지는 잘 모르겠다)
멤버가 팀의 id에 fk, 팀은 팀의 아이디에 pk를 둬서 1:1 연관관계로 매핑하고, lombook 이나 setTeam()을 지우고 createTeam()을 바꾸는 형식으로 두면 실수할 가능성도 현저히 줄어들고
코드 로직에 대한 이해만 잘 되어있으면 에러 날 일이 없다)
toString()같은 함수를 연관관계로 매핑하면 객체호출하면 A객체는 B객체 호출하고 B객체는 A객체를 호출해서 무한 반복 에러가 터짐
비슷하게 API를 이용하는 경우도 Entity값은 그냥 컨트롤러에서 DTO의 반환타입으로만 사용하는 것이 좋음
다시 한번 더 나가서 이 잘 묶는 과정을 실제로 적용할 수 있을지 잘 모르겠는데 일단은 강사님이 설계가 잘못되었다는 아래 예시처럼
member가 속한 Team의 member들을 알고 싶으면,
team -> member로 하면 될껄 
트랜직션으로 하면 팀 관리 class로 크게 둬도, member가 Team을 두먼 결국에 Team 관리 class에서 해당 member의 team을 조회하고, 해당 team에서 member를 조회하기 때문에
결과적으로 팀 관리라는 class를 둔다는 것 자체가 member의 개념 보다는 "팀을 관리"한다는 목적에 대해서만 강조되어, member를 자주 이용하는 경우 안 좋은 명시적인 용도가 발생하고 그 반대로
member 관리 class를 두면, team을 자주 이용하는 경우에도 마찬가지로 안 좋은 명시적인 용도가 발생한다
또한 이렇게 큰 클래스를 두면 중간에 최소한의 member나 team으로 DTO 타입으로 나누는 것이 좋은데, 이 경우에 결국은 Member -> teams에서 해당 team -> team에서 member호출 과정을 거친다
(또는 member관리 클래스에서 member랑 같은 팀 조회 -> 팀 클래스에서 해당 member들을 출력하는 경우로 좀 효과적이게 짤 수는 있지만, 이 경우 team이 자주 사용된다면 트랜잭션 상태가
member 중심이므로 비효율적이다)
전에 했던 과정 중 애매한게 이런 작업 같다
해당 회원이 가진 주문서를 조회하려면 Member<->Order의 경우 회원이 주문한 것들을 다 취소하려고 한다면
Member 중심으로 가면 마찬가지로 Member -> Order -> Member로 3번 거쳐가야 됨(MemberList로 등록된 것 중 해당 회원을 찾아서, 해당 회원이 주문한 제품키를 찾아서, 취소하고, 나중에
취소한게 남아있지 않도록 Member에 가서 해당 주문한 제품 등록도 취소해줘야 함)
(여기서는 Order 중심으로 가면 Order에 제품키만 넣어줘도, Order -> 주문 취소 만 해주면 되니 효과적임)
그리고, Order 중심으로 가면 회원 탈퇴할 경우 주문을 삭제해야 한다면
Order -> Member -> 탈퇴 이렇게 3번 과정이 거쳐가야됨 ( 여기서는 Member 중심으로 했을 때 Member -> 탈퇴만 하면 됨)
이런식으로 더 효과적으로 짤 수 있음
어차피 연관관계 매핑도 하나가 pk,또는 fk로 주도적이고 수동적인 관계가 아닌가 싶기도 한데,
저번에 배웠던 create()처럼 삭제할 떄 delete(),change()도 자동으로 mapped라고 설정되어있는 값을 Team.getMembers().해당원소 지우는 함수 
다만 list보다는 map구조가 좋을듯. (key를 name으로, value를 DTO 타입으로 묶어서 list로 짜면 find로 해당 값 조회하는 순간 최악은 O(N^2) 반면 map은 나은 편). 
마찬가지로 change()도 생각했을 때 list로 짜면 O(N^2)탐색이라 map이 더 효과적인듯












